#!/usr/bin/env perl
# Usage: generate-uaccess [UDEV_RULES_FILES...]
# Turns udev rules with TAG+=uacess in stdin/commandline into an smdev+processdev (as used in Artix-noudev) file.
# Extremely hackish, but manages to get elogind to cooperate with non-udev device managers,
# even though libudev-zero does not support tag enumeration.

# udev reimplements the shell's pattern matching engine. Insert Softpanorama's parody of Greenspun's tenth rule.
# This adds a POSIX compliant "equivalent" of [[.
print '#!/bin/sh
# Generated by generate-uaccess

# pattern matching
eq() {
	case $1 in ($2) return 0 ;; esac
	return 1
}
UACC=""

';

while (<>) {
	# Non-uaccess related rules are irrelevant.
	index($_, 'TAG+="uaccess"') > 0 or next;
	# For comparison.
	print("# $_");
	chomp;

	# cursed_udev_rule_to_associative_array.pl
	%props = map { m{(.*?[+=]?=)"(.*)"}; ($1, $2); } split /, +/, $_;

	# Array of conditions.
	@conds = ();

	for $_ (keys %props) {
		# Match subsystem...
		if ($_ eq 'SUBSYSTEM==') {
			push @conds, "eq \"\$SUBSYSTEM\" \Q$props{$_}\E";
		}

		# Match kernel device name...
		elsif ($_ eq 'KERNEL(S?)==') {
			# Pattern to match
			$pat = "\Q$props{$_}\E";
			# KERNEL matches whole name, KERNELS matches substring
			if ($1 eq 'S') { $pat = '\*' . $pat; }
			push @conds, "eq \"\$DEVNAME\" $pat";
		}

		# Extra environment variables.
		elsif (m{^ENV{(.*)}==$}) {
			push @conds, "eq \"\$\Q$1\E\" \Q$props{$_}\E";
		}

		elsif (m{^ATTRS?{(.*?)}==$}) {
			# Udev names de id/vendor, id/product, etc. files as idVendor and idProduct. Turn these into the filenames.
			$fname = $1; $fname =~ s@([a-z])([A-Z])@$1/\l$2@g;
			# Read file contents and match.
			push @conds, sprintf('{ read -r B < "/sys/$DEVPATH"/%s; eq "$B" %s; }',
				"\Q$fname\E", "\Q$props{$_}\E");
		}
	}

	# If we were able to recognize any conditions...
	if (scalar(@conds)) {
		# Make an && chain of conditions, and if all succeed, set the UACC variable. This will also succeed.
		# Since we're writing massive OR-groups of commands, this will immediately break out and go to the end.
		print '{ ', join(" && ", @conds), ' && UACC=$DEVNAME; } || ', "\n";
	}
}

# Complement || in previous line (null/true command)
print ":\n";

# Call the elogind handler for uaccess tag.
# Thanks to systemd for writing modular and other-system-components-agnostic software for once.
# You can replace this line with the equivalent for other seat managers.
print '[ "$UACC" ] && /usr/lib/elogind/elogind-uaccess-command "/dev/$UACC"' . "\n";
